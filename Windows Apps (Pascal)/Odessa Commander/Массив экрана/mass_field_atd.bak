unit mass_field_atd;


interface
        uses crt;

        const MaxX = 80;
        const MaxY = 25;


        type charmx = array [1..MaxY, 1..MaxX] of char;  {матрица символов}
        type colormx = array [1..MaxY, 1..MaxX] of byte; {матрица типа байт}
             charmx_pointer = ^charmx;   {указатель на сharmx}
             colormx_pointer = ^colormx;   {указатель на colormx}

        type Figure_position = record
                 x1, y1, x2, y2, color, backcolor : byte;
                 sym : char
        end;

        mass_field = object
        public

        procedure init;  {инициализация - создается новое поле}
        procedure get_from_file;  {взять из файла}
        procedure copy_to_file; {скопировать в файл}
        procedure addrectangle (position : Figure_position);
                                                        {зарисовать прямоугольную часть массива}
        procedure DrawForwardLine (position : Figure_position); {нарисовать линию вперед}
        procedure DrawDownLine (position : Figure_position);  {нарисовать линию вниз}
        procedure DrawPoint (X, Y, color, backcolor : byte; sym : char); {нарисовать один символ в указанном месте}
        procedure displaymass; {отобразить весь массив}
        procedure add_rectangleline (position : Figure_position); {рисуем линию прямоугольника}
        procedure add_String (S : String; X, Y, color, backcolor : byte);  {добавить строку}
        procedure DisplayLine (Y : byte); {отобразить строку, Y - номер строки}
        procedure DisplayScreen; {вывести весь массив на экран}
        procedure Display_partline (Y, X1, X2 : byte);
        procedure DisplayRectangle (X1, X2, Y1, Y2 : byte); {вывести прямоугольную часть экрана}


        private
             char_mass : charmx_pointer;      {матрица символов}
             text_mass : colormx_pointer; {матрица цвета}
             back_mass : colormx_pointer; {матрица фона}

        end;



        implementation


        procedure mass_field.init;    {инициализация}
         var i, i2 : byte;

       begin
              Getmem (char_mass, MaxX * MaxY);  {освобаждаем память для матрицы символов}
              Getmem (text_mass, MaxX * MaxY);  {освобождаем память для матрицы цвета}
              Getmem (back_mass, MaxX * MaxY);  {освобождаем память для матрицы фона}

              for i := 1 to MaxY do               {устанавливаем начальные значения для массивов}
              for i2 := 1 to MaxX do begin
                Char_mass^ [i, i2] := '*';  {пробел}
                Text_mass^ [i, i2] := 1;   {черный цвет}
                Back_mass^ [i, i2] := 0;   {черный цвет}
              end
        end;


        procedure mass_field.get_from_file;  {взять из файла}

         var char_file : file of charmx;   {файл символов}
             text_file : file of colormx;   {файл цвета}
             back_file : file of colormx;   {файл фона}

        begin
                Assign (char_file, 'cf.mf');    {cf - char file, mf - mass field}
                Assign (text_file, 'tf.mf');    {tf - text file}
                Assign (back_file, 'bf.mf');    {bf - back file}

                Reset (char_file);     {открываем}
                Reset (text_file);      {три}
                Reset (back_file);      {файла}

                Read (char_file, char_mass^);    {считываем }
                Read (text_file, text_mass^);    {массивы}
                Read (back_file, back_mass^);

                Close (char_file);       {закрываем}
                Close (text_file);       {файлы}
                Close (back_file);
           end;

        procedure mass_field.copy_to_file;

         var char_file : file of charmx;   {файл символов}
             text_file : file of colormx;   {файл цвета}
             back_file : file of colormx;   {файл фона}
        begin
                Assign (char_file, 'cf.mf');    {cf - char file, mf - mass field}
                Assign (text_file, 'tf.mf');    {tf - text file}
                Assign (back_file, 'bf.mf');    {bf - back file}

                Rewrite (char_file);     {открываем}
                Rewrite (text_file);      {три}
                Rewrite (back_file);      {файла}

                Write (char_file, char_mass^);    {записываем }
                Write (text_file, text_mass^);    {массивы}
                Write (back_file, back_mass^);

                Close (char_file);       {закрываем}
                Close (text_file);       {файлы}
                Close (back_file);
          end;


        procedure mass_field.displaymass;
           var i, i2 : byte;
           begin
                window (1, 1, MaxX, MaxY);
                clrscr;

                for i := 1 to MaxY do begin
                Gotoxy (1, i);  {переходим к х = 1 и к установленному y}
                for i2 := 1 to MaxX do begin
                 textbackground (Back_mass^[i, i2]);
                 textcolor (Text_mass^[i, i2]);
                 Write (Char_mass^[i, i2]);
                 end
               end;


        end;

        procedure mass_field.addrectangle (Position : Figure_position); {зарисовать прямоугольную часть}
             var i, i2 : byte;

             begin
                   for i := Position.y1 to Position.y2 do
                        for i2:= Position.x1 to Position.x2 do begin
                        Char_Mass^ [i, i2] := Position.sym;
                        Text_Mass^ [i, i2] := Position.color;
                        Back_Mass^ [i, i2] := Position.backcolor;
                        end
             end;

         procedure mass_field.DrawForwardLine (position : Figure_position); {рисуем линию вперед}
             var i : byte;
         begin
                for i := position.x1 to position.x2 do begin
                    with position do begin
                        Char_Mass^ [Y1, i] := sym;
                        Text_Mass^ [Y1, i] := color;
                        Back_Mass^ [Y1, i] := backcolor
                    end
                end
         end;

          procedure mass_field.DrawDownLine (position : Figure_position); {рисуем линию вниз}
             var i : byte;
          begin
                for i := position.y1 to position.y2 do begin
                    with position do begin
                          Char_Mass^ [i, X1] := sym;
                          Text_Mass^ [i, X1] := color;
                          Back_Mass^ [i, X1] := backcolor
                    end
                end
          end;

          procedure mass_field.DrawPoint (X, Y, color, backcolor : byte; sym : char); {рисуем символ}
                begin
                      Char_mass^ [Y, X] := sym;
                      Text_Mass^ [Y, X] := color;
                      Back_Mass^ [Y, X] := backcolor
                end;

         procedure mass_field.add_rectangleline (position : Figure_position); {обрисовываем прямоугольник}
           var Temp : Figure_position;
         begin


            Temp := position;

                        with position do begin     {рисуем углы}
               Self.DrawPoint (Y1, X1, color, backcolor, #213);
               Self.DrawPoint (Y1, X2, color, backcolor, #184);
               Self.DrawPoint (Y2, X1, color, backcolor, #212);
               Self.DrawPoint (Y2, X2, color, backcolor, #190);
                        end;

             inc (Temp.X1);
             dec (Temp.X2);
             Temp.sym := #205;
             Self.DrawForwardLine (Temp);   {рисуем верхнюю линию}

             Temp.Y1 := Temp.Y2;
             Self.DrawForwardLine (Temp);   {рисуем нижнюю линию}

             Temp.X1 := Position.X1;
             Self.DrawDownLine (position);   {рисуем левую линию вниз}

             Temp.X2 := Temp.X1;
             Self.DrawDownLine (position);   {рисуем правую линию вниз}

        end;

            procedure mass_field.add_String (S : String; X, Y, color, backcolor : byte);
                 var i2 : byte;
            begin


                  for i2 := 1 to Length (S) do begin
                          Char_Mass^ [Y, X] := S [i2];
                          Text_Mass^ [Y, X] := color;
                          Back_Mass^ [Y, X] := backcolor;

                     inc (X);
                     if X > 25 then
                     break;

                  end
            end;

            procedure mass_field.DisplayLine (Y : byte);
            var i : byte;
            begin
               if Y in [1..25] then begin
                 Gotoxy (1, Y);
                for i := 1 to MaxX do begin
                    textcolor (Text_Mass^ [Y, i]);
                    textbackground (Back_Mass^ [Y, i]);
                    Write (Char_Mass^ [Y, i])
                end
               end
            end;


            procedure mass_field.DisplayScreen;
            var Y : byte;
            begin
                 for Y := 1 to MaxY do
                 Self.DisplayLine (Y);
            end;


           procedure mass_field.Display_partline (Y, X1, X2 : byte);
           var i : byte;
           begin
                GotoXY (Y, X1);

                for i := X1 to X2 do begin
                    textcolor (Text_Mass^ [Y, i]);
                    textbackground (Back_Mass^ [Y, i]);
                    Write (Char_Mass^ [Y, i])
                end;
           end;

            procedure mass_field.DisplayRectangle (X1, X2, Y1, Y2 : byte);
            var i : byte;
            begin

                 Gotoxy (Y1, X1);

                 repeat

                        for i := X1 to X2 do begin
                    textcolor (Text_Mass^ [Y1, i]);
                    textbackground (Back_Mass^ [Y1, i]);
                    Write (Char_Mass^ [Y1, i])
                        end;
                       inc (Y1);

                 until Y1 > Y2
            end;

        end.






















